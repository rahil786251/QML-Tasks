
Open In Colab
TASK 3: Bell States and Entanglement Entropy
Aim
To construct Bell States using tensor products and to measure entanglement entropy in bipartite quantum systems.

1. Mathematical Model
1.1 Quantum Gates Representation
a. Hadamard Gate (H)
Transforms basis states as:
 
 

b. Identity Gate (I)
Leaves the qubit state unchanged:

c. Controlled-NOT (CNOT) Gate
Flips the target qubit if and only if the control qubit is in state 
:

1.2 Bell States Construction
Bell states are constructed by applying a Hadamard gate to the first qubit, followed by a CNOT operation between the two qubits.
The four Bell states are:
 
 
 
 

Each Bell state represents a maximally entangled two-qubit system.

1.3 Partial Trace Operation
Given a density matrix 
 for a bipartite system 
, the partial trace over subsystem 
 is defined as:
,
where 
 is an orthonormal basis for subsystem 
.

1.4 Entanglement Entropy (Von Neumann Entropy)
For a pure bipartite state 
, the entanglement entropy is the von Neumann entropy of the reduced density matrix:
,
where 
 are the eigenvalues of 
.
A maximally entangled state has 
, while a product (non-entangled) state has 
.

2. Algorithm
Define quantum gates 
, 
, and 
.
Construct the four Bell states using tensor products and gate operations.
Convert the state vectors into density matrices 
.
Compute the partial trace over one subsystem to obtain 
.
Find eigenvalues of 
 and calculate the von Neumann entropy.
Verify that all Bell states yield entropy 
 and that the product state 
 has 
.

!pip install qiskit
import numpy as np
from math import log2, sqrt
# Define quantum gates
H = 1/sqrt(2) * np.array([[1, 1], [1, -1]])  # Hadamard gate
I = np.eye(2)                                # Identity gate
CNOT = np.array([[1,0,0,0], [0,1,0,0], [0,0,0,1], [0,0,1,0]])  # CNOT gate
class BellStates:
    @staticmethod
    def phi_plus():
        """Construct |Φ⁺⟩ = (|00⟩ + |11⟩)/√2"""
        state = np.kron([1, 0], [1, 0])  # |00⟩
        state = np.kron(H, I) @ state    # Apply H to first qubit
        return CNOT @ state              # Apply CNOT

    @staticmethod
    def phi_minus():
        """Construct |Φ⁻⟩ = (|00⟩ - |11⟩)/√2"""
        state = np.kron([0, 1], [1, 0])  # |10⟩
        state = np.kron(H, I) @ state
        return CNOT @ state

    @staticmethod
    def psi_plus():
        """Construct |Ψ⁺⟩ = (|01⟩ + |10⟩)/√2"""
        state = np.kron([1, 0], [0, 1])  # |01⟩
        state = np.kron(H, I) @ state
        return CNOT @ state

    @staticmethod
    def psi_minus():
        """Construct |Ψ⁻⟩ = (|01⟩ - |10⟩)/√2"""
        state = np.kron([0, 1], [0, 1])  # |11⟩
        state = np.kron(H, I) @ state
        return CNOT @ state
def partial_trace(rho, dims, axis=0):
          """
          Compute partial trace of density matrix rho
          dims: list of dimensions of each subsystem [dA, dB]
          axis: 0 for tracing out B, 1 for tracing out A
          """
          dA, dB = dims
          if axis == 0:  # Trace out B
              rho_reduced = np.zeros((dA, dA), dtype=complex)
              for i in range(dA):
                  for j in range(dA):
                      for k in range(dB):
                          rho_reduced[i,j] += rho[i*dB + k, j*dB + k]
          else:  # Trace out A
              rho_reduced = np.zeros((dB, dB), dtype=complex)
              for i in range(dB):
                  for j in range(dB):
                      for k in range(dA):
                          rho_reduced[i,j] += rho[k*dB + i, k*dB + j]
          return rho_reduced
def entanglement_entropy(state):
    """
    Calculate entanglement entropy of bipartite state
    Input: state vector or density matrix
    Output: entanglement entropy
    """
    # Convert state to density matrix if it's a state vector
    if state.ndim == 1:
        rho = np.outer(state, state.conj())
    else:
        rho = state

     # Partial trace over subsystem B (assuming 2-qubit system)
    rho_A = partial_trace(rho, [2, 2], axis=1)

    # Compute eigenvalues (using eigh for Hermitian matrices)
    eigvals = np.linalg.eigvalsh(rho_A)

    # Calculate von Neumann entropy
    entropy = 0.0
    for lamda in eigvals:
        if lamda > 1e-10:  # avoid log(0)
            entropy -= lamda * log2(lamda)

    return entropy
       # Example usage
if __name__ == "__main__":
    # Construct Bell states
    phi_p = BellStates.phi_plus()
    phi_m = BellStates.phi_minus()
    psi_p = BellStates.psi_plus()
    psi_m = BellStates.psi_minus()

    print("\n" + "="*50)
    print("TASK 3: BELL STATES AND ENTANGLEMENT ENTROPY")
    print("="*50)

    print(f"Bell state |Φ⁺⟩ =", phi_p)
    print(f"Bell state |Φ⁻⟩ =", phi_m)
    print(f"Bell state |Ψ⁺⟩ =", psi_p)
    print(f"Bell state |Ψ⁻⟩ =", psi_m)

   # Verify entanglement entropy (should be 1 for maximally entangled states)
    print(f"Entanglement entropy of |Φ⁺⟩: {entanglement_entropy(phi_p):.4f}")
    print(f"Entanglement entropy of |Φ⁻⟩: {entanglement_entropy(phi_m):.4f}")
    print(f"Entanglement entropy of |Ψ⁺⟩: {entanglement_entropy(psi_p):.4f}")
    print(f"Entanglement entropy of |Ψ⁻⟩: {entanglement_entropy(psi_m):.4f}")

    # Verify product state has zero entanglement entropy
    product_state = np.kron([1, 0], [1, 0])  # |00⟩
    print(f"Entanglement entropy of |00⟩: {entanglement_entropy(product_state):.4f}")

!pip install qiskit-aer
from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector, partial_trace, entropy
from qiskit_aer import AerSimulator
import numpy as np
import pandas as pd

# Initialize simulator
simulator = AerSimulator()

def create_bell_state(bell_type):
    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    if bell_type == 'phi_minus':
        qc.z(0)
    elif bell_type == 'psi_plus':
        qc.x(1)
    elif bell_type == 'psi_minus':
        qc.z(0)
        qc.x(1)
    return qc

def calculate_entropy(qc):
    statevector = Statevector.from_instruction(qc)
    rho = partial_trace(statevector, [1])
    return entropy(rho, base=2)

state_data = []
states = {
    'phi_plus': '|Φ⁺⟩',
    'phi_minus': '|Φ⁻⟩',
    'psi_plus': '|Ψ⁺⟩',
    'psi_minus': '|Ψ⁻⟩',
    'product': '|00⟩'
}

print("Bell States Construction and Entanglement Analysis")
print("="*50)

for key, label in states.items():
    if key == 'product':
        qc = QuantumCircuit(2)
        print("\nProduct State:")
    else:
        qc = create_bell_state(key)
        print(f"\nBell State {label}:")

    # Display circuit
    print("Quantum Circuit:")
    print(qc)

    # Calculate and display results
    entropy_val = calculate_entropy(qc)
    statevector = Statevector.from_instruction(qc)

    print("\nStatevector:")
    print(np.round(statevector.data, 3))

    print(f"Entanglement Entropy: {round(entropy_val, 3)}")
    print("-"*40)

    state_data.append({
        'State': label,
        'Entanglement Entropy': round(entropy_val, 3),
        'Score (out of 1)': f"{round(entropy_val, 3)}/1"
    })

# Create and display summary table
print("\nSummary Table:")
print("="*50)
df = pd.DataFrame(state_data)
print(df.to_string(index=False))
     
Requirement already satisfied: qiskit in /usr/local/lib/python3.11/dist-packages (2.1.1)
Requirement already satisfied: rustworkx>=0.15.0 in /usr/local/lib/python3.11/dist-packages (from qiskit) (0.16.0)
Requirement already satisfied: numpy<3,>=1.17 in /usr/local/lib/python3.11/dist-packages (from qiskit) (2.0.2)
Requirement already satisfied: scipy>=1.5 in /usr/local/lib/python3.11/dist-packages (from qiskit) (1.16.0)
Requirement already satisfied: dill>=0.3 in /usr/local/lib/python3.11/dist-packages (from qiskit) (0.3.8)
Requirement already satisfied: stevedore>=3.0.0 in /usr/local/lib/python3.11/dist-packages (from qiskit) (5.4.1)
Requirement already satisfied: typing-extensions in /usr/local/lib/python3.11/dist-packages (from qiskit) (4.14.1)
Requirement already satisfied: pbr>=2.0.0 in /usr/local/lib/python3.11/dist-packages (from stevedore>=3.0.0->qiskit) (6.1.1)
Requirement already satisfied: setuptools in /usr/local/lib/python3.11/dist-packages (from pbr>=2.0.0->stevedore>=3.0.0->qiskit) (75.2.0)

==================================================
TASK 3: BELL STATES AND ENTANGLEMENT ENTROPY
==================================================
Bell state |Φ⁺⟩ = [0.70710678 0.         0.         0.70710678]
Bell state |Φ⁻⟩ = [ 0.70710678  0.          0.         -0.70710678]
Bell state |Ψ⁺⟩ = [0.         0.70710678 0.70710678 0.        ]
Bell state |Ψ⁻⟩ = [ 0.          0.70710678 -0.70710678  0.        ]
Entanglement entropy of |Φ⁺⟩: 1.0000
Entanglement entropy of |Φ⁻⟩: 1.0000
Entanglement entropy of |Ψ⁺⟩: 1.0000
Entanglement entropy of |Ψ⁻⟩: 1.0000
Entanglement entropy of |00⟩: 0.0000
Collecting qiskit-aer
  Downloading qiskit_aer-0.17.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (8.3 kB)
Requirement already satisfied: qiskit>=1.1.0 in /usr/local/lib/python3.11/dist-packages (from qiskit-aer) (2.1.1)
Requirement already satisfied: numpy>=1.16.3 in /usr/local/lib/python3.11/dist-packages (from qiskit-aer) (2.0.2)
Requirement already satisfied: scipy>=1.0 in /usr/local/lib/python3.11/dist-packages (from qiskit-aer) (1.16.0)
Requirement already satisfied: psutil>=5 in /usr/local/lib/python3.11/dist-packages (from qiskit-aer) (5.9.5)
Requirement already satisfied: python-dateutil>=2.8.0 in /usr/local/lib/python3.11/dist-packages (from qiskit-aer) (2.9.0.post0)
Requirement already satisfied: six>=1.5 in /usr/local/lib/python3.11/dist-packages (from python-dateutil>=2.8.0->qiskit-aer) (1.17.0)
Requirement already satisfied: rustworkx>=0.15.0 in /usr/local/lib/python3.11/dist-packages (from qiskit>=1.1.0->qiskit-aer) (0.16.0)
Requirement already satisfied: dill>=0.3 in /usr/local/lib/python3.11/dist-packages (from qiskit>=1.1.0->qiskit-aer) (0.3.8)
Requirement already satisfied: stevedore>=3.0.0 in /usr/local/lib/python3.11/dist-packages (from qiskit>=1.1.0->qiskit-aer) (5.4.1)
Requirement already satisfied: typing-extensions in /usr/local/lib/python3.11/dist-packages (from qiskit>=1.1.0->qiskit-aer) (4.14.1)
Requirement already satisfied: pbr>=2.0.0 in /usr/local/lib/python3.11/dist-packages (from stevedore>=3.0.0->qiskit>=1.1.0->qiskit-aer) (6.1.1)
Requirement already satisfied: setuptools in /usr/local/lib/python3.11/dist-packages (from pbr>=2.0.0->stevedore>=3.0.0->qiskit>=1.1.0->qiskit-aer) (75.2.0)
Downloading qiskit_aer-0.17.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (12.4 MB)
   ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 12.4/12.4 MB 96.6 MB/s eta 0:00:00
Installing collected packages: qiskit-aer
Successfully installed qiskit-aer-0.17.1
Bell States Construction and Entanglement Analysis
==================================================

Bell State |Φ⁺⟩:
Quantum Circuit:
     ┌───┐     
q_0: ┤ H ├──■──
     └───┘┌─┴─┐
q_1: ─────┤ X ├
          └───┘

Statevector:
[0.707+0.j 0.   +0.j 0.   +0.j 0.707+0.j]
Entanglement Entropy: 1.0
----------------------------------------

Bell State |Φ⁻⟩:
Quantum Circuit:
     ┌───┐     ┌───┐
q_0: ┤ H ├──■──┤ Z ├
     └───┘┌─┴─┐└───┘
q_1: ─────┤ X ├─────
          └───┘     

Statevector:
[ 0.707+0.j  0.   +0.j  0.   +0.j -0.707+0.j]
Entanglement Entropy: 1.0
----------------------------------------

Bell State |Ψ⁺⟩:
Quantum Circuit:
     ┌───┐          
q_0: ┤ H ├──■───────
     └───┘┌─┴─┐┌───┐
q_1: ─────┤ X ├┤ X ├
          └───┘└───┘

Statevector:
[0.   +0.j 0.707+0.j 0.707+0.j 0.   +0.j]
Entanglement Entropy: 1.0
----------------------------------------

Bell State |Ψ⁻⟩:
Quantum Circuit:
     ┌───┐     ┌───┐
q_0: ┤ H ├──■──┤ Z ├
     └───┘┌─┴─┐├───┤
q_1: ─────┤ X ├┤ X ├
          └───┘└───┘

Statevector:
[ 0.   +0.j -0.707+0.j  0.707+0.j  0.   +0.j]
Entanglement Entropy: 1.0
----------------------------------------

Product State:
Quantum Circuit:
     
q_0: 
     
q_1: 
     

Statevector:
[1.+0.j 0.+0.j 0.+0.j 0.+0.j]
Entanglement Entropy: 0.0
----------------------------------------

Summary Table:
==================================================
State  Entanglement Entropy Score (out of 1)
 |Φ⁺⟩                   1.0            1.0/1
 |Φ⁻⟩                   1.0            1.0/1
 |Ψ⁺⟩                   1.0            1.0/1
 |Ψ⁻⟩                   1.0            1.0/1
 |00⟩                   0.0            0.0/1

#!pip install qiskit
#!pip install qiskit_aer
from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector, partial_trace, entropy
from qiskit_aer import AerSimulator
import numpy as np
import pandas as pd

# Initialize simulator
simulator = AerSimulator()

def create_bell_state(bell_type):
    qc = QuantumCircuit(2)
    qc.h(0)
    qc.cx(0, 1)
    if bell_type == 'phi_minus':
        qc.z(0)
    elif bell_type == 'psi_plus':
        qc.x(1)
    elif bell_type == 'psi_minus':
        qc.z(0)
        qc.x(1)
    return qc

def calculate_entropy(qc):
    statevector = Statevector.from_instruction(qc)
    rho = partial_trace(statevector, [1])
    return entropy(rho, base=2)

state_data = []
states = {
    'phi_plus': '|Φ⁺⟩',
    'phi_minus': '|Φ⁻⟩',
    'psi_plus': '|Ψ⁺⟩',
    'psi_minus': '|Ψ⁻⟩',
    'product': '|00⟩'
}

print("Bell States Construction and Entanglement Analysis")
print("="*50)

for key, label in states.items():
    if key == 'product':
        qc = QuantumCircuit(2)
        print("\nProduct State:")
    else:
        qc = create_bell_state(key)
        print(f"\nBell State {label}:")

    # Display circuit
    print("Quantum Circuit:")
    print(qc)

    # Calculate and display results
    entropy_val = calculate_entropy(qc)
    statevector = Statevector.from_instruction(qc)

    print("\nStatevector:")
    print(np.round(statevector.data, 3))

    print(f"Entanglement Entropy: {round(entropy_val, 3)}")
    print("-"*40)

    state_data.append({
        'State': label,
        'Entanglement Entropy': round(entropy_val, 3),
        'Score (out of 1)': f"{round(entropy_val, 3)}/1"
    })

# Create and display summary table
print("\nSummary Table:")
print("="*50)
df = pd.DataFrame(state_data)
print(df.to_string(index=False))
     
Bell States Construction and Entanglement Analysis
==================================================

Bell State |Φ⁺⟩:
Quantum Circuit:
     ┌───┐     
q_0: ┤ H ├──■──
     └───┘┌─┴─┐
q_1: ─────┤ X ├
          └───┘

Statevector:
[0.707+0.j 0.   +0.j 0.   +0.j 0.707+0.j]
Entanglement Entropy: 1.0
----------------------------------------

Bell State |Φ⁻⟩:
Quantum Circuit:
     ┌───┐     ┌───┐
q_0: ┤ H ├──■──┤ Z ├
     └───┘┌─┴─┐└───┘
q_1: ─────┤ X ├─────
          └───┘     

Statevector:
[ 0.707+0.j  0.   +0.j  0.   +0.j -0.707+0.j]
Entanglement Entropy: 1.0
----------------------------------------

Bell State |Ψ⁺⟩:
Quantum Circuit:
     ┌───┐          
q_0: ┤ H ├──■───────
     └───┘┌─┴─┐┌───┐
q_1: ─────┤ X ├┤ X ├
          └───┘└───┘

Statevector:
[0.   +0.j 0.707+0.j 0.707+0.j 0.   +0.j]
Entanglement Entropy: 1.0
----------------------------------------

Bell State |Ψ⁻⟩:
Quantum Circuit:
     ┌───┐     ┌───┐
q_0: ┤ H ├──■──┤ Z ├
     └───┘┌─┴─┐├───┤
q_1: ─────┤ X ├┤ X ├
          └───┘└───┘

Statevector:
[ 0.   +0.j -0.707+0.j  0.707+0.j  0.   +0.j]
Entanglement Entropy: 1.0
----------------------------------------

Product State:
Quantum Circuit:
     
q_0: 
     
q_1: 
     

Statevector:
[1.+0.j 0.+0.j 0.+0.j 0.+0.j]
Entanglement Entropy: 0.0
----------------------------------------

Summary Table:
==================================================
State  Entanglement Entropy Score (out of 1)
 |Φ⁺⟩                   1.0            1.0/1
 |Φ⁻⟩                   1.0            1.0/1
 |Ψ⁺⟩                   1.0            1.0/1
 |Ψ⁻⟩                   1.0            1.0/1
 |00⟩                   0.0            0.0/1
4. Result
All four Bell states were successfully constructed using Hadamard and CNOT gates. The calculated entanglement entropy for each Bell state was found to be 
, confirming that they are maximally entangled. In contrast, the product state 
 exhibited zero entanglement entropy (
), verifying that it is a separable state. These results confirm the theoretical predictions and validate the quantum mechanical behavior of entanglement.
